//go:generate ../internal/cmd/mktemplates/mktemplates templates.go templates

package main

import "text/template"

func init() {
	template.Must(templates.Parse("{{define \"_interfaceMethod\"}}\t\t\tInterfaceID: {{.Interface.Id | printf \"%#x\"}},\n\t\t\tMethodID: {{.ID}},\n\t\t\tInterfaceName: {{.Interface.DisplayName | printf \"%q\"}},\n\t\t\tMethodName: {{.OriginalName | printf \"%q\"}},\n{{end}}{{define \"annotation\"}}const {{.Node.Name}} = uint64({{.Node.Id | printf \"%#x\"}})\n{{end}}{{define \"enum\"}}{{with .Annotations.Doc}}// {{.}}\n{{end}}type {{.Node.Name}} uint16\n\n{{with .EnumValues}}// Values of {{$.Node.Name}}.\nconst (\n{{range .}}{{.FullName}} {{$.Node.Name}} = {{.Val}}\n{{end}}\n)\n\n// String returns the enum's constant name.\nfunc (c {{$.Node.Name}}) String() string {\n\tswitch c {\n\t{{range .}}{{if .Tag}}case {{.FullName}}: return {{printf \"%q\" .Tag}}\n\t{{end}}{{end}}\n\tdefault: return \"\"\n\t}\n}\n\n// {{$.Node.Name}}FromString returns the enum value with a name,\n// or the zero value if there's no such value.\nfunc {{$.Node.Name}}FromString(c string) {{$.Node.Name}} {\n\tswitch c {\n\t{{range .}}{{if .Tag}}case {{printf \"%q\" .Tag}}: return {{.FullName}}\n\t{{end}}{{end}}\n\tdefault: return 0\n\t}\n}\n{{end}}\n\ntype {{.Node.Name}}_List struct { {{capnp}}.List }\n\nfunc New{{.Node.Name}}_List(s *{{capnp}}.Segment, sz int32) ({{.Node.Name}}_List, error) {\n\tl, err := {{capnp}}.NewUInt16List(s, sz)\n\tif err != nil {\n\t\treturn {{.Node.Name}}_List{}, err\n\t}\n\treturn {{.Node.Name}}_List{l.List}, nil\n}\n\nfunc (l {{.Node.Name}}_List) At(i int) {{.Node.Name}} {\n\tul := {{capnp}}.UInt16List{List: l.List}\n\treturn {{.Node.Name}}(ul.At(i))\n}\n\nfunc (l {{.Node.Name}}_List) Set(i int, v {{.Node.Name}}) {\n\tul := {{capnp}}.UInt16List{List: l.List}\n\tul.Set(i, uint16(v))\n}\n{{end}}{{define \"hasfield\"}}func (s {{.Node.Name}}) Has{{.Field.Name | title}}() bool {\n\tp, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\treturn p.IsValid() || err != nil \n}\n{{end}}{{define \"interfaceClient\"}}{{with .Annotations.Doc}}// {{.}}\n{{end}}type {{.Node.Name}} struct { Client {{capnp}}.Client }\n\n{{range .Methods}}func (c {{$.Node.Name}}) {{.Name | title}}(ctx {{context}}.Context, params func({{.Params.RemoteName $.Node}}) error, opts ...{{capnp}}.CallOption) {{.Results.RemoteName $.Node}}_Promise {\n\tif c.Client == nil {\n\t\treturn {{.Results.RemoteName $.Node}}_Promise{Pipeline: {{capnp}}.NewPipeline({{capnp}}.ErrorAnswer({{capnp}}.ErrNullClient))}\n\t}\n\tcall := &{{capnp}}.Call{\n\t\tCtx: ctx,\n\t\tMethod: {{capnp}}.Method{\n\t\t\t{{template \"_interfaceMethod\" .}}\n\t\t},\n\t\tOptions: {{capnp}}.NewCallOptions(opts),\n\t}\n\tif params != nil {\n\t\tcall.ParamsSize = {{.Params.ObjectSize}}\n\t\tcall.ParamsFunc = func(s {{capnp}}.Struct) error { return params({{.Params.RemoteName $.Node}}{Struct: s}) }\n\t}\n\treturn {{.Results.RemoteName $.Node}}_Promise{Pipeline: {{capnp}}.NewPipeline(c.Client.Call(call))}\n}\n{{end}}\n{{end}}{{define \"interfaceServer\"}}type {{.Node.Name}}_Server interface {\n\t{{range .Methods}}\n\t{{.Name | title}}({{.Interface.RemoteName $.Node}}_{{.Name}}) error\n\t{{end}}\n}\n\nfunc {{.Node.Name}}_ServerToClient(s {{.Node.Name}}_Server) {{.Node.Name}} {\n\tc, _ := s.({{server}}.Closer)\n\treturn {{.Node.Name}}{Client: {{server}}.New({{.Node.Name}}_Methods(nil, s), c)}\n}\n\nfunc {{.Node.Name}}_Methods(methods []{{server}}.Method, s {{.Node.Name}}_Server) []{{server}}.Method {\n\tif cap(methods) == 0 {\n\t\tmethods = make([]{{server}}.Method, 0, {{len .Methods}})\n\t}\n\t{{range .Methods}}\n\tmethods = append(methods, {{server}}.Method{\n\t\tMethod: {{capnp}}.Method{\n\t\t\t{{template \"_interfaceMethod\" .}}\n\t\t},\n\t\tImpl: func(c {{context}}.Context, opts {{capnp}}.CallOptions, p, r {{capnp}}.Struct) error {\n\t\t\tcall := {{.Interface.RemoteName $.Node}}_{{.Name}}{c, opts, {{.Params.RemoteName $.Node}}{Struct: p}, {{.Results.RemoteName $.Node}}{Struct: r} }\n\t\t\treturn s.{{.Name | title}}(call)\n\t\t},\n\t\tResultsSize: {{.Results.ObjectSize}},\n\t})\n\t{{end}}\n\treturn methods\n}\n{{range .Methods}}{{if eq .Interface.Id $.Node.Id}}\n// {{$.Node.Name}}_{{.Name}} holds the arguments for a server call to {{$.Node.Name}}.{{.Name}}.\ntype {{$.Node.Name}}_{{.Name}} struct {\n\tCtx     {{context}}.Context\n\tOptions {{capnp}}.CallOptions\n\tParams  {{.Params.RemoteName $.Node}}\n\tResults {{.Results.RemoteName $.Node}}\n}\n{{end}}{{end}}\n{{end}}{{define \"listValue\"}}{{.Typ}}{List: {{capnp}}.MustUnmarshalRootPtr({{.Value}}).List()}{{end}}{{define \"newStructFunc\"}}func New{{.Node.Name}}(s *{{capnp}}.Segment) ({{.Node.Name}}, error) {\n\tst, err := {{capnp}}.NewStruct(s, {{.Node.ObjectSize}})\n\tif err != nil {\n\t\treturn {{.Node.Name}}{}, err\n\t}\n\treturn {{.Node.Name}}{st}, nil\n}\n\nfunc NewRoot{{.Node.Name}}(s *{{capnp}}.Segment) ({{.Node.Name}}, error) {\n\tst, err := {{capnp}}.NewRootStruct(s, {{.Node.ObjectSize}})\n\tif err != nil {\n\t\treturn {{.Node.Name}}{}, err\n\t}\n\treturn {{.Node.Name}}{st}, nil\n}\n\nfunc ReadRoot{{.Node.Name}}(msg *{{capnp}}.Message) ({{.Node.Name}}, error) {\n\troot, err := msg.RootPtr()\n\tif err != nil {\n\t\treturn {{.Node.Name}}{}, err\n\t}\n\treturn {{.Node.Name}}{root.Struct()}, nil\n}\n{{end}}{{define \"pointerValue\"}}{{capnp}}.MustUnmarshalRootPtr({{.Value}}){{end}}{{define \"promise\"}}// {{.Node.Name}}_Promise is a wrapper for a {{.Node.Name}} promised by a client call.\ntype {{.Node.Name}}_Promise struct { *{{capnp}}.Pipeline }\n\nfunc (p {{.Node.Name}}_Promise) Struct() ({{.Node.Name}}, error) {\n\ts, err := p.Pipeline.Struct()\n\treturn {{.Node.Name}}{s}, err\n}\n\n{{end}}{{define \"promiseFieldAnyPointer\"}}func (p {{.Node.Name}}_Promise) {{.Field.Name | title}}() *{{capnp}}.Pipeline {\n\treturn p.Pipeline.GetPipeline({{.Field.Slot.Offset}})\n}\n\n{{end}}{{define \"promiseFieldInterface\"}}func (p {{.Node.Name}}_Promise) {{.Field.Name | title}}() {{.Interface.RemoteName .Node}} {\n\treturn {{.Interface.RemoteName .Node}}{Client: p.Pipeline.GetPipeline({{.Field.Slot.Offset}}).Client()}\n}\n\n{{end}}{{define \"promiseFieldStruct\"}}func (p {{.Node.Name}}_Promise) {{.Field.Name | title}}() {{.Struct.RemoteName .Node}}_Promise {\n\treturn {{.Struct.RemoteName .Node}}_Promise{Pipeline: p.Pipeline.{{if .Default.IsValid}}GetPipelineDefault({{.Field.Slot.Offset}}, {{.Default}}){{else}}GetPipeline({{.Field.Slot.Offset}}){{end}} }\n}\n\n{{end}}{{define \"promiseGroup\"}}func (p {{.Node.Name}}_Promise) {{.Field.Name | title}}() {{.Group.Name}}_Promise { return {{.Group.Name}}_Promise{p.Pipeline} }\n{{end}}{{define \"settag\"}}{{if hasDiscriminant .Field}}s.Struct.SetUint16({{discriminantOffset .Node}}, {{.Field.DiscriminantValue}})\n{{end}}{{end}}{{define \"structBoolField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() bool {\n\treturn {{if .Default}}!{{end}}s.Struct.Bit({{.Field.Slot.Offset}})\n}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v bool) {\n\t{{template \"settag\" .}}s.Struct.SetBit({{.Field.Slot.Offset}}, {{if .Default}}!{{end}}v)\n}\n\n{{end}}{{define \"structDataField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() ({{.FieldType}}, error) {\n\tp, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t{{with .Default}}return {{$.FieldType}}(p.DataDefault({{printf \"%#v\" .}})), nil{{else}}return {{.FieldType}}(p.Data()), nil{{end}}\n}\n\n{{template \"hasfield\" .}}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v {{.FieldType}}) error {\n\t{{template \"settag\" .}}d, err := {{capnp}}.NewData(s.Struct.Segment(), []byte(v))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.Struct.SetPtr({{.Field.Slot.Offset}}, d.List.ToPtr())\n}\n\n{{end}}{{define \"structEnums\"}}type {{.Node.Name}}_Which uint16\n\nconst (\n{{range .Fields}}\t{{$.Node.Name}}_Which_{{.Name}} {{$.Node.Name}}_Which = {{.DiscriminantValue}}\n{{end}}\n)\n\nfunc (w {{.Node.Name}}_Which) String() string {\n\tconst s = {{.EnumString.ValueString | printf \"%q\"}}\n\tswitch w {\n\t{{range $i, $f := .Fields}}case {{$.Node.Name}}_Which_{{.Name}}:\n\t\treturn s{{$.EnumString.SliceFor $i}}\n\t{{end}}\n\t}\n\treturn \"{{.Node.Name}}_Which(\" + {{strconv}}.FormatUint(uint64(w), 10) + \")\"\n}\n\n{{end}}{{define \"structFloatField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() float{{.Bits}} {\n\treturn {{math}}.Float{{.Bits}}frombits(s.Struct.Uint{{.Bits}}({{.Offset}}){{with .Default}} ^ {{printf \"%#x\" .}}{{end}})\n}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v float{{.Bits}}) {\n\t{{template \"settag\" .}}s.Struct.SetUint{{.Bits}}({{.Offset}}, {{math}}.Float{{.Bits}}bits(v){{with .Default}}^{{printf \"%#x\" .}}{{end}})\n}\n\n{{end}}{{define \"structFuncs\"}}{{if gt .Node.StructGroup.DiscriminantCount 0}}\nfunc (s {{.Node.Name}}) Which() {{.Node.Name}}_Which {\n\treturn {{.Node.Name}}_Which(s.Struct.Uint16({{discriminantOffset .Node}}))\n}\n{{end}}{{end}}{{define \"structGroup\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() {{.Group.Name}} { return {{.Group.Name}}(s) }{{if hasDiscriminant .Field}}\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}() { {{template \"settag\" .}} }\n{{end}}{{end}}{{define \"structIntField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() {{.ReturnType}} {\n\treturn {{.ReturnType}}(s.Struct.Uint{{.Bits}}({{.Offset}}){{with .Default}} ^ {{.}}{{end}})\n}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v {{.ReturnType}}) {\n\t{{template \"settag\" .}}s.Struct.SetUint{{.Bits}}({{.Offset}}, uint{{.Bits}}(v){{with .Default}}^{{.}}{{end}})\n}\n\n{{end}}{{define \"structInterfaceField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() {{.FieldType}} {\n\tp, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\t\n\t\treturn {{.FieldType}}{}\n\t}\n\treturn {{.FieldType}}{Client: p.Interface().Client()}\n}\n\n{{template \"hasfield\" .}}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v {{.FieldType}}) error {\n\t{{template \"settag\" .}}seg := s.Segment()\n\tif seg == nil {\n\t\t\n\t\treturn nil\n\t}\n\tvar in capnp.Interface\n\tif v.Client != nil {\n\t\tin = {{capnp}}.NewInterface(seg, seg.Message().AddCap(v.Client))\n\t}\n\treturn s.Struct.SetPtr({{.Field.Slot.Offset}}, in.ToPtr())\n}\n\n{{end}}{{define \"structList\"}}// {{.Node.Name}}_List is a list of {{.Node.Name}}.\ntype {{.Node.Name}}_List struct{ {{capnp}}.List }\n\n// New{{.Node.Name}} creates a new list of {{.Node.Name}}.\nfunc New{{.Node.Name}}_List(s *{{capnp}}.Segment, sz int32) ({{.Node.Name}}_List, error) {\n\tl, err := {{capnp}}.NewCompositeList(s, {{.Node.ObjectSize}}, sz)\n\tif err != nil  {\n\t\treturn {{.Node.Name}}_List{}, err\n\t}\n\treturn {{.Node.Name}}_List{l}, nil\n}\n\nfunc (s {{.Node.Name}}_List) At(i int) {{.Node.Name}} { return {{.Node.Name}}{ s.List.Struct(i) } }\nfunc (s {{.Node.Name}}_List) Set(i int, v {{.Node.Name}}) error { return s.List.SetStruct(i, v.Struct) }\n{{end}}{{define \"structListField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() ({{.FieldType}}, error) {\n\tp, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\treturn {{.FieldType}}{}, err\n\t}\n\t{{if .Default.IsValid}}l, err := p.ListDefault({{.Default}})\n\tif err != nil {\n\t\treturn {{.FieldType}}{}, err\n\t}\n\treturn {{.FieldType}}{List: l}, nil{{else}}return {{.FieldType}}{List: p.List()}, nil{{end}}\n}\n\n{{template \"hasfield\" .}}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v {{.FieldType}}) error {\n\t{{template \"settag\" .}}return s.Struct.SetPtr({{.Field.Slot.Offset}}, v.List.ToPtr())\n}\n\n{{end}}{{define \"structPointerField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() ({{capnp}}.Pointer, error) {\n\t{{if .Default.IsValid}}p, err := s.Struct.Pointer({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn {{capnp}}.PointerDefault(p, {{.Default}}){{else}}return s.Struct.Pointer({{.Field.Slot.Offset}}){{end}}\n}\n\n{{template \"hasfield\" .}}\n\nfunc (s {{.Node.Name}}) {{.Field.Name | title}}Ptr() ({{capnp}}.Ptr, error) {\n\t{{if .Default.IsValid}}p, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn p.Default({{.Default}}){{else}}return s.Struct.Ptr({{.Field.Slot.Offset}}){{end}}\n}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v {{capnp}}.Pointer) error {\n\t{{template \"settag\" .}}return s.Struct.SetPointer({{.Field.Slot.Offset}}, v)\n}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}Ptr(v {{capnp}}.Ptr) error {\n\t{{template \"settag\" .}}return s.Struct.SetPtr({{.Field.Slot.Offset}}, v)\n}\n\n{{end}}{{define \"structStructField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() ({{.FieldType}}, error) {\n\tp, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\treturn {{.FieldType}}{}, err\n\t}\n\t{{if .Default.IsValid}}ss, err := p.StructDefault({{.Default}})\n\tif err != nil {\n\t\treturn {{.FieldType}}{}, err\n\t}\n\treturn {{.FieldType}}{Struct: ss}, nil{{else}}return {{.FieldType}}{Struct: p.Struct()}, nil{{end}}\n}\n\n{{template \"hasfield\" .}}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v {{.FieldType}}) error {\n\t{{template \"settag\" .}}return s.Struct.SetPtr({{.Field.Slot.Offset}}, v.Struct.ToPtr())\n}\n\n// New{{.Field.Name | title}} sets the {{.Field.Name}} field to a newly\n// allocated {{.FieldType}} struct, preferring placement in s's segment.\nfunc (s {{.Node.Name}}) New{{.Field.Name | title}}() ({{.FieldType}}, error) {\n\t{{template \"settag\" .}}ss, err := {{.TypeNode.RemoteNew .Node}}(s.Struct.Segment())\n\tif err != nil {\n\t\treturn {{.FieldType}}{}, err\n\t}\n\terr = s.Struct.SetPtr({{.Field.Slot.Offset}}, ss.Struct.ToPtr())\n\treturn ss, err\n}\n\n{{end}}{{define \"structTextField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() (string, error) {\n\tp, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t{{with .Default}}return p.TextDefault({{printf \"%q\" .}}), nil{{else}}return p.Text(), nil{{end}}\n}\n\n{{template \"hasfield\" .}}\n\nfunc (s {{.Node.Name}}) {{.Field.Name | title}}Bytes() ([]byte, error) {\n\tp, err := s.Struct.Ptr({{.Field.Slot.Offset}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t{{with .Default}}return p.DataDefault([]byte({{printf \"%q\" .}})), nil{{else}}return p.Data(), nil{{end}}\n}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v string) error {\n\t{{template \"settag\" .}}t, err := {{capnp}}.NewText(s.Struct.Segment(), v)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.Struct.SetPtr({{.Field.Slot.Offset}}, t.List.ToPtr())\n}\n\n{{end}}{{define \"structTypes\"}}{{with .Annotations.Doc}}// {{.}}\n{{end}}type {{.Node.Name}} {{if .IsBase}}struct{ {{capnp}}.Struct }{{else}}{{.BaseNode.Name}}{{end}}\n{{end}}{{define \"structUintField\"}}func (s {{.Node.Name}}) {{.Field.Name | title}}() uint{{.Bits}} {\n\treturn s.Struct.Uint{{.Bits}}({{.Offset}}){{with .Default}} ^ {{.}}{{end}}\n}\n\nfunc (s {{.Node.Name}}) Set{{.Field.Name | title}}(v uint{{.Bits}}) {\n\t{{template \"settag\" .}}s.Struct.SetUint{{.Bits}}({{.Offset}}, v{{with .Default}}^{{.}}{{end}})\n}\n\n{{end}}{{define \"structValue\"}}{{.Typ.RemoteName .Node}}{Struct: {{capnp}}.MustUnmarshalRootPtr({{.Value}}).Struct()}{{end}}{{define \"structVoidField\"}}{{if hasDiscriminant .Field}}func (s {{.Node.Name}}) Set{{.Field.Name | title}}() {\n\t{{template \"settag\" .}}\n}\n\n{{end}}{{end}}"))
}
