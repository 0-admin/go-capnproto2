package main

import (
	"strings"
)

func (p *file) resolveCTypes() {
	for _, t := range p.types {
		switch t.typ {
		case structType, interfaceType, methodType:
			t.name = strings.Replace(t.name, "·", "_", -1)
		case enumType, unionType:
			t.name = strings.Replace(t.name, "·", "_", -1)
			t.enumPrefix = t.name + "_"
		case voidType:
			t.name = "void"
		case boolType:
			t.name = "int"
		case int8Type:
			t.name = "int8_t"
		case int16Type:
			t.name = "int16_t"
		case int32Type:
			t.name = "int32_t"
		case int64Type:
			t.name = "int64_t"
		case uint8Type:
			t.name = "uint8_t"
		case uint16Type:
			t.name = "uint16_t"
		case uint32Type:
			t.name = "uint32_t"
		case uint64Type:
			t.name = "uint64_t"
		case float32Type:
			t.name = "float"
		case float64Type:
			t.name = "double"
		case stringType:
			t.name = "char"
		case listType, dataType:
			t.name = "struct capn_ptr"
		default:
			panic("unhandled")
		}
	}
}

func (t *typ) writeCStruct() {
	out("struct %s {\n", t.name)

	for _, f := range t.sortFields {
		if f.typ.isptr() {
			if f.comment != "" {
				out("/* %s */\n", f.comment)
			}

			switch f.typ.typ {
			case structType, interfaceType:
				out("\tstruct %s_ptr %s;\n", f.typ.name, f.name)
			case stringType, listType, dataType:
				out("\tstruct capn_ptr %s;\n", f.name)
			}
		}
	}

	for _, f := range t.sortFields {
		if !f.typ.isptr() {
			if f.comment != "" {
				out("/* %s */\n", f.comment)
			}

			switch f.typ.typ {
			case boolType:
				out("\tunsigned char %s : 1;\n", f.name)
			case enumType, unionType:
				out("\tenum %s %s;\n", f.typ.name, t.name)
			default:
				out("\t%s %s;\n", f.typ.name, t.name)
			}
		}
	}

	out("};")
}

var cheader = `#ifndef CAPN_%s
#define CAPN_%s
#include <capnproto.h>
#include <stdint.h>
/* AUTOGENERATED - DO NOT EDIT */
`

func (p *file) writeCHeader(name string) {
	hdr := strings.Replace(strings.ToUpper(name), ".", "_", -1)
	out(cheader, hdr, hdr)

	for _, c := range p.constants {
		if c.comment != "" {
			out("/* %s */\n", c.comment)
		}

		switch c.typ.typ {
		case structType:
			out("extern const struct %s_ptr %s;\n", c.typ.name, c.name)

		case stringType, listType, dataType:
			out("extern const struct capn_ptr %s;\n", c.name)

		case int8Type, uint8Type, int16Type, uint16Type,
			int32Type, uint32Type, int64Type, uint64Type,
			float32Type, float64Type, enumType, boolType:
			out("extern const %s %s;\n", c.typ.name, c.name)

		default:
			panic("unhandled")
		}
	}

	for _, t := range p.types {
		if t.comment != "" {
			out("/* %s */\n", t.comment)
		}
		switch t.typ {
		case enumType, unionType:
			out("enum %s {\n", t.name)
			for i, f := range t.fields {
				if i > 0 {
					out(",\n")
				}
				if f.comment != "" {
					out("/* %s */\n", f.comment)
				}

				out("\t%s%s = %d", t.enumPrefix, f.name, t.name)
			}
			out("\n};\n\n")

		case structType, methodType:
			t.writeCStruct()
			out("struct %s_ptr {struct capn_ptr ptr;};\n", t.name)
			out("struct %s_ptr new_%s(struct capn_segment*, struct %s*);\n", t.name, t.name, t.name)
			out("void read_%s(struct %s_ptr*, struct %s*);\n", t.name, t.name, t.name)
			out("void write_%s(struct %s_ptr*, const struct %s*);\n", t.name, t.name, t.name)
			out("\n")
		}
	}

	out("#endif\n")
}

func (p *file) writeCSource(name string) {
}
